---
title: 高性能MySQL 第一章 MySQL架构与历史
date: 2017-02-21 19:20:43
tags: 'mysql'
---

MySQL的特性是它的`存储引擎架构`。

这种设计将查询处理(`Query Processing`)及其他系统任务(`Server Task`) 和`数据的存储/提取`相分离。

在使用时根据具体情况选择存储引擎。

## MySQL逻辑架构

![MySQL服务器逻辑架构图](http://img.dnbcw.info/2012316/3881291.png)

由上图可以主要分为三层：

第一层架构 主要功能：连接处理，授权认证，安全等。

第二层架构 大多数MySQL的核心服务都在这一层：查询解析、分析、优化、缓存以及所有的内置函数(eg: 日期、时间、数学、加密等函数)，所有跨存储引擎的功能都在这一层实现：存储过程、触发器、视图等。

第三层架构 包含了存储引擎 负责MySQL中数据的存储和提取。 服务器通过API与存储引擎进行通信，API屏蔽了不同引擎之间的差异。

### 连接管理与安全性

每个客户端连接都会在服务器进程中拥有一个线程，这个连接的查询只会在这个单独的线程中执行。

服务器会缓存线程或者使用线程池技术，不需要为每个连接创建一个线程，因而使用较少的线程来服务大量的连接。

当客户连接服务器的时候，服务器会对其进行认证，基于用户名、密码、主机信息。

客户连接上服务器，执行某个操作时，服务器会对其进行权限判断，判断该用户是否有权限进行该项操作。

### 优化与执行

MySQL会解析查询,并创建解析树，然后对其进行各种优化，包括重写查询、决定表的读取顺序，以及选取合适的索引等。

用户可以使用特殊的关键字提示(`hint`)优化器，影响其决策过程。

也可以请求优化器解释(`explain`)优化过程，让客户知道服务器如何进行优化。

以便用户修改查询和schema、修改相关配置，使之高效运行。

优化器并不关心表使用的是什么存储引擎，但存储引擎对于优化查询是有影响的。

对于SELECT语句，在解析查询之前，服务器会先检查查询缓存(`Query Cache`),如果能找到对应的查询，服务器就会直接返回查询缓存中的结果集。

---

## 并发控制

无论何时，只要有多个查询需要在同一时刻修改数据，就会产生并发控制问题。

MySQL的并发控制包含两个层面： 服务器层和存储引擎层

MySQL的并发控制主要靠`锁`机制解决。

### 读写锁

`读锁`(read lock) 也叫 `共享锁`(shared lock)

`写锁`(write lock) 也叫 `排他锁`(exclusive lock)

读锁是共享的，是相互不阻塞的。多个客户可以同时读取同一个资源而不受干扰。

写锁是排他的，一个写锁会阻塞其他的读锁和写锁。

在实际的数据库系统中，每时每刻都会发生锁定。大多数时候，MySQL锁的内部管理都是透明的。

### 锁粒度

加锁会消耗资源。锁的各种操作，包括获得锁，检查所是否解除，释放锁，都会增加系统开销。

锁的粒度越小，就能对修改的数据片进行更精确的锁定，系统的并发程度就越高，但是系统的开销就越大。

**表锁(table lock)**

表锁是MySQL中最基本的一种锁策略，并且是开销最小的策略,它会锁定整张表。

当一个用户在对表进行写操作(插入、删除、更新等)前，需要先获取写锁，这会阻塞其他用户对该表的所有读写操作。

只有在没有写锁时，其他用户才能获得读锁。

尽管存储引擎可以管理自己的锁，MySQL本身还是会使用各种有效的表锁来实现不同的目的。

比如，服务器会为诸如ALTER TABLE之类的语句使用表锁，而忽略存储引擎的锁机制。

**行级锁(row lock)**

行级锁可以最大程度的支持并发操作(同时也带来了最大的锁开销)

行级锁只在存储引擎层次实现，而在MySQL服务器层没有实现，服务器层完全不了解存储引擎中的锁实现。

所有存储引擎都以自己的方式实现了锁机制。

---

## 事务

事务就是一组原子性的SQL查询，或者说一个独立的工作单元。

事务内的语句，要么全部成功，要么全部失败。

事务的ACID特性，表示`原子性`(atomicity)、`一致性`(consistency)、`隔离性`(isolation)、`永久性`(durability)

用户可以根据业务是否需要事务处理，来选择合适的存储引擎。

对于不需要事务的查询类应用，可以选择一个非事务型的存储引擎。

### 隔离级别

在SQL标准中定义了4种隔离级别，每一种级别都规定了一个事务中所做的修改，哪些在事务内和事务间是可见的，哪些是不可见的。

较低级别的隔离通常可以执行更高的并发，系统的开销也更低。

**READ UNCOMMITTED** (未提交读)

**READ COMMITTED** (提交读)

**REPEATABLE READ** (可重复读)

**SERIALIZABLE** (可串行化)

|隔离级别|脏读可能性|不可重复读可能性|幻读可能性|加锁读|
|:-:|:-:|:-:|:-:|:-:|
|READ UNCOMMITTED|YES|YES|YES|NO|
|READ COMMITTED|NO|YES|YES|NO|
|REPEATABLE READ|NO|NO|YES|NO|
|SERIALIZABLE|NO|NO|NO|YES|

### 死锁

### 事务日志

### MySQL中的事务

---

## 多版本并发控制

---

## Mysql的存储引擎

### InnoDB 存储引擎

InnoDB存储引擎是MySQL自5.5版本以来的默认事务型引擎，也是最重要、使用最广泛的存储引擎。

它被设计用来处理大量的短期事务，在非事务行的存储的需求中也很流行。

除非有非常特别的原因需要使用其他的存储引擎，否则应该优先考虑使用InnoDB引擎。

### MyISAM 存储引擎

在MySQL5.1及之前的版本，MyISAM是默认的存储引擎，MyISAM不支持事务和行级锁。

### 其他存储引擎

**Archive引擎** 

Archive存储引擎只支持INSERT和SELECT操作

**Backhole引擎**

Backhole没有实现任何的存储机制，他会丢弃所有插入的数据，不做保存，服务器会记录Backhole表的日志。

**CSV引擎**

CSV引擎可以将普通的csv文件作为MySQL的表来处理，但是这种引表不支持索引。

**Memory引擎**

Memory引擎数据保存在内存中，查询速度快，但是重启之后数据丢失，表结构还会保留。

**NDB集群引擎**

MySQL服务器，NDB集群存储引擎，以及分布式的、share-nothing的、容灾的、高可用的NDB数据库的组合，被称为MySQL集群(`MySQL Cluster`)。

### 第三方存储引擎

---

## Mysql时间线

---

## Mysql的开发模式

--- 